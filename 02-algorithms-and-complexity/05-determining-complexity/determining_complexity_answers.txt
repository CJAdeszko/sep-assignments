1. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def goodbye_world(n)
     puts "Goodbye World! #{n}"
    end

    O(1) - the 'puts' statement takes constant time to execute.

What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def find_largest(collection)
     largest = collection[0]
     collection.length.times do |i|
       if collection[i] >= largest
         largest = collection[i]
       end
     end
     largest
    end

    O(n) - the amount of time it takes the program to execute grows with the size of the collection since each
    item in the collection must be compared with 'largest'.



What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def find_largest(collection)
     largest = collection[0][0]
     collection.length.times do |i|
       subcollection = collection[i]
       subcollection.length.times do |j|
         if subcollection[j] >= largest
           largest = subcollection[j]
         end
       end
     end
     largest
    end

    O(n^2) - the amount of time it takes for the algorithm to execute grows with both collection sizes - i.e as the collection
    of arrays grows in length the time it takes to execute increases linearly. Additionally, as the size of the array at each index of the
    collection increases, the time needed to execute increases linearly again.


What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def numbers(n)
     if (n == 0)
       return 0
     elsif (n == 1)
       return 1
     else
       return numbers(n-1) + numbers(n-2)
     end
    end

  O(2^n) - the amount of time it takes the algorithm to execute grows with the number of recursive calls to the function
  as the number passed in grows

  0 => 0
  1 => 0
  2 => 1
  3 => 2
  4 => 3
  5 => 4


                            num(5)
                  /                        \
                num(4)                       num(3)
          /              \               /            \
        num(3)          num(2)         num(2)         num(1)
      /       \       /       \       /       \
    num(2)  num(1)  num(1)   num(0) num(1)  num(0)
    /     \
num(1) num(0)


What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def iterative(n)
     num1 = 0
     num2 = 1

     i = 0
     while i < n-1
       tmp = num1 + num2
       num1 = num2
       num2 = tmp
       i+=1
     end

     num2
    end

    O(n) - the number of iterations the algorithm requires to execute increases linearly as the size of n increases.



What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

  def sort(collection, from=0, to=nil)
   if to == nil
     # Sort the whole collection, by default
     to = collection.count - 1
   end

   if from >= to
     # Done sorting
     return
   end

   # Take a pivot value, at the far left
   pivot = collection[from]

   # Min and Max pointers
   min = from
   max = to

   # Current free slot
   free = min

   while min < max
     if free == min # Evaluate collection[max]
       if collection[max] <= pivot # Smaller than pivot, must move
         collection[free] = collection[max]
         min += 1
         free = max
       else
         max -= 1
       end
     elsif free == max # Evaluate collection[min]
       if collection[min] >= pivot # Bigger than pivot, must move
         collection[free] = collection[min]
         max -= 1
         free = min
       else
         min += 1
       end
     else
       raise "Inconsistent state"
     end
   end

   collection[free] = pivot

   sort collection, from, free - 1
   sort collection, free + 1, to

   collection
  end

  O(n log n)
