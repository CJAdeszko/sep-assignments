1. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def goodbye_world(n)
     puts "Goodbye World! #{n}"
    end

    O(1) - the 'puts' statement takes constant time to execute.

2. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def find_largest(collection)
     largest = collection[0]
     collection.length.times do |i|
       if collection[i] >= largest
         largest = collection[i]
       end
     end
     largest
    end

    O(n) - the amount of time it takes the program to execute grows with the size of the collection since each
    item in the collection must be compared with 'largest'.



3. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def find_largest(collection)
     largest = collection[0][0]
     collection.length.times do |i|
       subcollection = collection[i]
       subcollection.length.times do |j|
         if subcollection[j] >= largest
           largest = subcollection[j]
         end
       end
     end
     largest
    end

    O(n) - Because the algorithm does work on a 2D array, there are two loops. However, a comparison is only made once
    for each item in the collection resulting in a O(n) complexity. 


4. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def numbers(n)
     if (n == 0)
       return 0
     elsif (n == 1)
       return 1
     else
       return numbers(n-1) + numbers(n-2)
     end
    end

  O(2^n) - the amount of time it takes the algorithm to execute grows with the number of recursive calls to the function
  as the number passed in grows. Starting an n = 2, there are two recursive calls for each value n. So, at n = 2 we have
  recursive calls for numbers(1) and numbers(0). At n = 3, there are recursive calls for numbers(2) - this leads to an
  additional two recursive calls for numbers(1) and numbers(0) - and numbers(1) which returns 1. At n = 4, there are
  recursive calls for numbers(3) - this leads to an additional two recursive calls for numbers(2) and numbers(1) - and
  numbers (2) - which leads to an additional two recursive calls for numbers(1) and numbers(0).



                            num(5)
                  /                        \
                num(4)                       num(3)
          /              \               /            \
        num(3)          num(2)         num(2)         num(1)
      /       \       /       \       /       \
    num(2)  num(1)  num(1)   num(0) num(1)  num(0)
    /     \
num(1) num(0)


5. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

    def iterative(n)
     num1 = 0
     num2 = 1

     i = 0
     while i < n-1
       tmp = num1 + num2
       num1 = num2
       num2 = tmp
       i+=1
     end

     num2
    end

    O(n) - the number of iterations the algorithm requires to execute increases linearly as the size of n increases.



6. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.

  def sort(collection, from=0, to=nil)
   if to == nil
     # Sort the whole collection, by default
     to = collection.count - 1
   end

   if from >= to
     # Done sorting
     return
   end

   # Take a pivot value, at the far left
   pivot = collection[from]

   # Min and Max pointers
   min = from
   max = to

   # Current free slot
   free = min

   while min < max
     if free == min # Evaluate collection[max]
       if collection[max] <= pivot # Smaller than pivot, must move
         collection[free] = collection[max]
         min += 1
         free = max
       else
         max -= 1
       end
     elsif free == max # Evaluate collection[min]
       if collection[min] >= pivot # Bigger than pivot, must move
         collection[free] = collection[min]
         max -= 1
         free = min
       else
         min += 1
       end
     else
       raise "Inconsistent state"
     end
   end

   collection[free] = pivot

   sort collection, from, free - 1
   sort collection, free + 1, to

   collection
  end

  O(n log n) - As the function is called, the amount of data required to sort is cut by about half on each recursive call leading
  me to believe that there is a time complexity of O(n log n).
